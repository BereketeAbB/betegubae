<!DOCTYPE html>
<html lang="am">
<head>
  <meta charset="UTF-8">
  <title>Lyrics Parser Tool</title>
  <style>
    body {
      font-family: "Noto Sans Ethiopic", sans-serif;
      line-height: 1.4;
      font-size: 16px;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
      background-color: #f8f9fa;
    }

    h2 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 20px;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 30px;
    }

    .input-section, .output-section {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    textarea {
      width: 100%;
      height: 300px;
      font-family: "Noto Sans Ethiopic", monospace;
      font-size: 14px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      resize: vertical;
    }

    button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
    }

    button:hover {
      background-color: #2980b9;
    }

    .preview-section {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-top: 20px;
    }

    .preview-text {
      font-size: 24px;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    .char-with-symbols {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      vertical-align: bottom;
      margin: 0 2px;
    }

    .melody-line {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1px;
      min-height: 12px;
      font-family: 'ZemaYared', 'Noto Sans Ethiopic', sans-serif;
    }

    .base-char {
      font-size: 24px;
      min-height: 25px;
      display: flex;
      align-items: flex-end;
      font-family: 'Noto Sans Ethiopic', sans-serif;
    }

    .black-symbol {
      color: black;
      font-size: 0.5em;
      font-weight: bold;
      margin: 0;
      line-height: 0.8;
    }

    .red-symbol {
      color: red;
      font-size: 0.5em;
      font-weight: bold;
      margin: 0;
      line-height: 0.8;
    }

    .empty-symbol {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin: 0 1px;
    }

    .code-block {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      border-left: 4px solid #3498db;
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 12px;
      overflow-x: auto;
    }

    .line-break {
      display: block;
      height: 10px;
    }

    /* Load ZemaYared font */
    @font-face {
      font-family: 'ZemaYared';
      src: url('./ZemaYared.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
  </style>
</head>

<body>

  <h2>የውዳሴ ማርያም ጽሑፍ አተረጓጎሚ</h2>

  <div class="container">
    <div class="input-section">
      <h3>ጽሑፍ አስገባ</h3>
      <textarea id="input-text" placeholder="ጽሑፍህን እዚህ አስገባ (ለምሳሌ: ክቡ[ቡበ][,]‹ሠረ›ር ሞቱ[በእ][ጠጠ]‹ቀለ›)">
ክቡ[ቡበ][,]‹ሠረ›ር ሞቱ[በእ][ጠጠ]‹ቀለ› ለ[,][~]ጻድ[.][,]ቅ[ፈ][ቀ]‹ነኪ› በቅ[~]ድመ[,] እ[V]ግዚ[.][.]ብሔር። ክቡ[ቡበ][,]‹ሠረ›ር ሞቱ[በእ][ጠጠ]‹ቀለ› ለ[,][~]ጻድ[.][,]ቅ[ፈ][ቀ]‹ነኪ› በቅ[~]ድመ[,] እ[V]ግዚ[.][.]ብሔር።</textarea>
      <button onclick="parseText()">ጽሑፍ አተርጎም</button>
    </div>

    <div class="output-section">
      <h3>የተከፋፈለ ጽሑፍ</h3>
      <div id="output" class="code-block">
// ውጤቱ እዚህ ይታያል...
      </div>
    </div>
  </div>

  <div class="preview-section">
    <h3>የጽሑፍ ቅጂ</h3>
    <div id="preview" class="preview-text">
      <!-- Preview will be rendered here -->
    </div>
  </div>

  <script>
    // Function to parse text into character-symbol pairs
    function parseTextWithSymbols(text) {
      const result = [];
      let currentChar = '';
      let symbols = [];

      let i = 0;
      while (i < text.length) {
        const char = text[i];

        if (char === '[') {
          // Found black symbol
          const symbolEnd = text.indexOf(']', i);
          if (symbolEnd !== -1) {
            const symbolContent = text.substring(i + 1, symbolEnd);
            symbols.push({
              content: symbolContent,
              type: 'black'
            });
            i = symbolEnd + 1;
            continue;
          }
        } else if (char === '‹') {
          // Found red symbol
          const symbolEnd = text.indexOf('›', i);
          if (symbolEnd !== -1) {
            const symbolContent = text.substring(i + 1, symbolEnd);
            symbols.push({
              content: symbolContent,
              type: 'red'
            });
            i = symbolEnd + 1;
            continue;
          }
        } else if (char === '<') {
          // Found red symbol (alternative)
          const symbolEnd = text.indexOf('>', i);
          if (symbolEnd !== -1) {
            const symbolContent = text.substring(i + 1, symbolEnd);
            symbols.push({
              content: symbolContent,
              type: 'red'
            });
            i = symbolEnd + 1;
            continue;
          }
        } else {
          // Regular character
          if (currentChar) {
            result.push({
              char: currentChar,
              symbols: [...symbols]
            });
            symbols = [];
          }
          currentChar = char;
        }
        i++;
      }

      // Add last character
      if (currentChar || symbols.length > 0) {
        result.push({
          char: currentChar,
          symbols: [...symbols]
        });
      }

      return result;
    }

    // NEW: Function to split text into segments with line breaks at ።
    function splitTextIntoSegments(text) {
      const segments = [];
      let currentSegment = '';

      // Split by spaces but preserve them
      const words = text.split(/( )/); // Split by spaces but keep the spaces

      for (let i = 0; i < words.length; i++) {
        const word = words[i];

        if (word.trim() === '።') {
          // Add current segment plus the ።
          if (currentSegment) {
            segments.push(currentSegment + word);
          } else {
            segments.push(word);
          }
          // Add line break marker
          segments.push('\n');
          currentSegment = '';
        } else if (word === ' ' && currentSegment === '') {
          // Preserve leading spaces
          currentSegment += word;
        } else if (word === ' ' && i < words.length - 1) {
          // Add space to current segment
          currentSegment += word;
        } else {
          // Add word to current segment
          currentSegment += word;
        }
      }

      // Add the last segment if any
      if (currentSegment.trim()) {
        segments.push(currentSegment);
      }

      return segments;
    }

    // Function to render preview
    function renderPreview(text) {
      const preview = document.getElementById('preview');
      preview.innerHTML = '';

      const segments = splitTextIntoSegments(text);

      segments.forEach((segment, segmentIndex) => {
        if (segment === '\n') {
          // Add line break
          const lineBreak = document.createElement('div');
          lineBreak.classList.add('line-break');
          preview.appendChild(lineBreak);
        } else {
          // Render text segment
          const segmentContainer = document.createElement('span');
          segmentContainer.style.display = 'inline';

          const words = segment.split(/( )/); // Split by spaces but keep them

          words.forEach((word, wordIndex) => {
            if (word === ' ') {
              // Add space
              segmentContainer.appendChild(document.createTextNode(' '));
            } else if (word.trim()) {
              // Render word with symbols
              const wordContainer = document.createElement('span');
              wordContainer.style.display = 'inline-block';
              wordContainer.style.margin = '0 2px';

              const parsed = parseTextWithSymbols(word);

              parsed.forEach((item, index) => {
                const charWithSymbols = document.createElement("span");
                charWithSymbols.classList.add("char-with-symbols");

                // Create ONE symbol per melody line (stacked vertically)
                // Reverse the symbols so last symbol appears closest to text
                const reversedSymbols = [...item.symbols].reverse();

                reversedSymbols.forEach((symbol, symbolIndex) => {
                  const melodyLineDiv = document.createElement("div");
                  melodyLineDiv.classList.add("melody-line");

                  const symbolSpan = document.createElement("span");
                  if (symbol.content === "") {
                    // Empty symbol
                    symbolSpan.classList.add("empty-symbol");
                    symbolSpan.innerHTML = "•";
                    symbolSpan.style.color = "lightgray";
                    symbolSpan.title = "Empty symbol";
                  } else {
                    // Non-empty symbol
                    symbolSpan.classList.add(`${symbol.type}-symbol`);
                    symbolSpan.textContent = symbol.content;
                  }
                  melodyLineDiv.appendChild(symbolSpan);
                  charWithSymbols.appendChild(melodyLineDiv);
                });

                // Add base character
                const baseChar = document.createElement("span");
                baseChar.classList.add("base-char");
                baseChar.textContent = item.char;
                charWithSymbols.appendChild(baseChar);

                wordContainer.appendChild(charWithSymbols);
              });

              segmentContainer.appendChild(wordContainer);
            }
          });

          preview.appendChild(segmentContainer);
        }
      });
    }

    // Main parse function
    function parseText() {
      const inputText = document.getElementById('input-text').value;
      const segments = splitTextIntoSegments(inputText);

      let output = '';
      let dataArray = [];
      let lineIndex = 0;

      let currentLine = '';
      segments.forEach(segment => {
        if (segment === '\n') {
          // End of line - add to data array
          if (currentLine.trim()) {
            const time = 1.14 + (lineIndex * 0.1);
            const dataObject = {
              time: time.toFixed(2),
              end: (time + 0.04).toFixed(2),
              text: currentLine.trim()
            };
            dataArray.push(dataObject);
            output += `{ time: ${dataObject.time}, end: ${dataObject.end}, text: "${currentLine.trim()}" },\n`;
            lineIndex++;
            currentLine = '';
          }
        } else {
          // Add segment to current line
          currentLine += segment;
        }
      });

      // Add the last line if any
      if (currentLine.trim()) {
        const time = 1.14 + (lineIndex * 0.1);
        const dataObject = {
          time: time.toFixed(2),
          end: (time + 0.04).toFixed(2),
          text: currentLine.trim()
        };
        dataArray.push(dataObject);
        output += `{ time: ${dataObject.time}, end: ${dataObject.end}, text: "${currentLine.trim()}" },\n`;
      }

      // Display output
      document.getElementById('output').textContent = output;

      // Render preview
      renderPreview(inputText);
    }

    // Initialize with example
    document.addEventListener('DOMContentLoaded', function() {
      parseText();
    });
  </script>

</body>
</html>